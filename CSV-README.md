# Signal Evaluation Data - LLM Trading Agent Guide

This document explains how to read and interpret the CSV files generated by the CalmCrypto Signal Evaluation System to make trading decisions.

## Quick Start

```python
import pandas as pd
from pathlib import Path

# Load data from an output directory
output_dir = Path("output/2025-12-24_123456")

# 1. Read metadata to know which asset
metadata = pd.read_csv(output_dir / "metadata.csv")
asset = metadata[metadata['parameter'] == 'asset']['value'].values[0]
print(f"Asset: {asset}")  # e.g., "BTC"

# 2. Read summary to find best signals
summary = pd.read_csv(output_dir / "summary.csv", index_col=0)
top_signal = summary.iloc[0]['signal_name']
print(f"Best signal: {top_signal}")

# 3. Read signal data to get current value
signal_data = pd.read_csv(output_dir / f"{top_signal}_data.csv", index_col=0, parse_dates=True)
current_value = signal_data['signal_value'].iloc[-1]
print(f"Current {top_signal}: {current_value}")
```

## Directory Structure

Each evaluation run creates a timestamped folder:

```
output/
  2025-12-24_123456/
    metadata.csv              # Run parameters (asset, timeframe)
    summary.csv               # Signal rankings
    {signal}_data.csv         # Time series for each signal
    {signal}_metrics.csv      # Detailed metrics for each signal
```

## File Reference

### metadata.csv

Contains run parameters. **Read this first** to know which asset was analyzed.

| Parameter | Example | Description |
|-----------|---------|-------------|
| `asset` | BTC | Asset symbol (BTC, ETH, SOL, etc.) |
| `data_hours` | 168 | Hours of historical data (168 = 7 days) |
| `step` | 5m | Data interval |
| `signals_evaluated` | 15 | Number of signals analyzed |
| `generation_time` | 2025-12-24 16:30:00 | When analysis was run |

```python
metadata = pd.read_csv(output_dir / "metadata.csv")
asset = metadata[metadata['parameter'] == 'asset']['value'].values[0]
```

### summary.csv

Master ranking of all signals by predictive power. **Use this to choose which signals to trade.**

| Column | Type | Description |
|--------|------|-------------|
| `rank` | int | Ranking position (1 = best) |
| `signal_name` | str | Signal identifier |
| `composite_score` | float | Overall score (0-1, higher = better) |
| `best_spearman_ic` | float | Information Coefficient (-1 to 1) |
| `hit_rate` | float | Directional accuracy (0-1) |
| `is_contrarian` | bool | True if signal predicts OPPOSITE direction |
| `effective_hit_rate` | float | True accuracy after contrarian adjustment |
| `lead_lag_score` | float | How much signal leads price (0-1) |
| `granger_significant` | bool | Statistically significant predictor |

```python
summary = pd.read_csv(output_dir / "summary.csv", index_col=0)

# Get top 3 signals
top_signals = summary.head(3)['signal_name'].tolist()

# Filter for only statistically significant signals
significant = summary[summary['granger_significant'] == True]
```

### {signal}_data.csv

Time series data for each signal. **Use this to get current signal values.**

| Column | Type | Description |
|--------|------|-------------|
| `timestamp` | datetime | Time of observation |
| `signal_value` | float | Signal value at that time |
| `btc_price` | float | Asset price at that time |
| `forward_return_5min` | float | Actual return 5 min later |
| `forward_return_1hr` | float | Actual return 1 hour later |
| `forward_return_4hr` | float | Actual return 4 hours later |
| `forward_return_1day` | float | Actual return 1 day later |

```python
data = pd.read_csv(output_dir / "rsi_zscore_data.csv", index_col=0, parse_dates=True)

# Get most recent signal value
current_signal = data['signal_value'].iloc[-1]
current_price = data['btc_price'].iloc[-1]

# Get signal change direction
signal_rising = data['signal_value'].iloc[-1] > data['signal_value'].iloc[-2]
```

### {signal}_metrics.csv

Detailed evaluation metrics for a single signal.

| Metric | Description |
|--------|-------------|
| `best_spearman_ic` | Correlation with future returns |
| `hit_rate` | Raw directional accuracy |
| `is_contrarian` | Whether to invert the signal |
| `effective_hit_rate` | Accuracy after inversion if contrarian |
| `best_lag` | Optimal look-ahead periods (in 5-min units) |
| `granger_p_value` | Statistical significance (lower = more significant) |

```python
metrics = pd.read_csv(output_dir / "rsi_zscore_metrics.csv")

# Get specific metric
hit_rate = metrics[metrics['metric'] == 'hit_rate']['value'].values[0]
is_contrarian = metrics[metrics['metric'] == 'is_contrarian']['value'].values[0] == 'True'
```

## Understanding the Metrics

### Composite Score

The `composite_score` (0-1) combines multiple metrics with these weights:
- 30% Information Coefficient (correlation strength)
- 25% IC-IR (consistency of correlation)
- 20% Effective Hit Rate (directional accuracy)
- 15% Lead-Lag Score (signal leads price)
- 10% Granger Score (statistical causality)

**Higher is better.** Signals with score > 0.5 are strong predictors.

### Hit Rate & Contrarian Signals

`hit_rate` measures how often signal direction matches price direction:
- **> 50%**: Direct signal - trade WITH the signal
- **< 50%**: Contrarian signal - trade OPPOSITE to the signal
- **= 50%**: No edge - ignore this signal

**Critical**: A 36% hit rate is just as valuable as 64% - you just invert the signal!

```python
# Check if contrarian
is_contrarian = summary.loc[1, 'hit_rate'] < 0.5

# Get effective accuracy (always > 50%)
effective_hr = summary.loc[1, 'effective_hit_rate']
```

### Information Coefficient (IC)

`best_spearman_ic` measures correlation between signal and future returns:
- **Positive IC**: Signal rises -> Price rises
- **Negative IC**: Signal rises -> Price falls
- **|IC| > 0.1**: Meaningful correlation
- **|IC| > 0.2**: Strong correlation

### Lead-Lag Score

`lead_lag_score` (0-1) indicates if signal predicts price:
- **> 0.5**: Signal leads price (predictive)
- **< 0.5**: Signal lags price (reactive, less useful)
- **`best_lag`**: Optimal prediction horizon in 5-min periods

## Trading Decision Framework

### Step 1: Identify Asset

```python
metadata = pd.read_csv(output_dir / "metadata.csv")
asset = metadata[metadata['parameter'] == 'asset']['value'].values[0]
# asset = "BTC" -> Trade BTCUSDT
```

### Step 2: Select Top Signals

```python
summary = pd.read_csv(output_dir / "summary.csv", index_col=0)

# Option A: Top N by composite score
top_signals = summary.head(3)['signal_name'].tolist()

# Option B: Only statistically significant
significant = summary[summary['granger_significant'] == True]
top_signals = significant.head(3)['signal_name'].tolist()

# Option C: Minimum score threshold
strong = summary[summary['composite_score'] > 0.4]
top_signals = strong['signal_name'].tolist()
```

### Step 3: Check Signal Direction (Direct vs Contrarian)

```python
signal_name = top_signals[0]
signal_row = summary[summary['signal_name'] == signal_name].iloc[0]

is_contrarian = signal_row['hit_rate'] < 0.5
# OR
is_contrarian = signal_row['is_contrarian'] == True
```

### Step 4: Get Current Signal State

```python
data = pd.read_csv(output_dir / f"{signal_name}_data.csv", index_col=0, parse_dates=True)

current_value = data['signal_value'].iloc[-1]
previous_value = data['signal_value'].iloc[-2]

signal_rising = current_value > previous_value
signal_falling = current_value < previous_value
```

### Step 5: Determine Trade Action

```python
def get_trade_signal(signal_rising: bool, is_contrarian: bool) -> str:
    """
    Determine trade direction based on signal movement and type.

    Returns: "LONG", "SHORT", or "HOLD"
    """
    if is_contrarian:
        # Invert the signal
        if signal_rising:
            return "SHORT"  # Signal up -> expect price down
        elif signal_falling:
            return "LONG"   # Signal down -> expect price up
    else:
        # Direct signal
        if signal_rising:
            return "LONG"   # Signal up -> expect price up
        elif signal_falling:
            return "SHORT"  # Signal down -> expect price down

    return "HOLD"
```

## Complete Trading Decision Function

```python
import pandas as pd
from pathlib import Path
from typing import Dict, Any

def analyze_signals(output_dir: str) -> Dict[str, Any]:
    """
    Analyze signal evaluation output and return trading recommendation.

    Args:
        output_dir: Path to signal evaluation output directory

    Returns:
        Dict with asset, signals, and trade recommendations
    """
    output_path = Path(output_dir)

    # Load metadata
    metadata = pd.read_csv(output_path / "metadata.csv")
    meta_dict = dict(zip(metadata['parameter'], metadata['value']))
    asset = meta_dict['asset']

    # Load summary
    summary = pd.read_csv(output_path / "summary.csv", index_col=0)

    # Get top 3 signals
    recommendations = []

    for idx, row in summary.head(3).iterrows():
        signal_name = row['signal_name']

        # Load signal data
        data = pd.read_csv(
            output_path / f"{signal_name}_data.csv",
            index_col=0,
            parse_dates=True
        )

        # Current state
        current_value = data['signal_value'].iloc[-1]
        previous_value = data['signal_value'].iloc[-2]
        signal_rising = current_value > previous_value

        # Check if contrarian
        is_contrarian = row['hit_rate'] < 0.5

        # Determine direction
        if is_contrarian:
            direction = "SHORT" if signal_rising else "LONG"
        else:
            direction = "LONG" if signal_rising else "SHORT"

        recommendations.append({
            'signal': signal_name,
            'rank': idx,
            'score': row['composite_score'],
            'hit_rate': row['effective_hit_rate'],
            'is_contrarian': is_contrarian,
            'current_value': current_value,
            'signal_direction': 'rising' if signal_rising else 'falling',
            'trade_direction': direction,
            'confidence': row['composite_score'] * row['effective_hit_rate']
        })

    # Aggregate recommendation (majority vote weighted by confidence)
    long_conf = sum(r['confidence'] for r in recommendations if r['trade_direction'] == 'LONG')
    short_conf = sum(r['confidence'] for r in recommendations if r['trade_direction'] == 'SHORT')

    if long_conf > short_conf * 1.2:  # 20% threshold
        final_direction = "LONG"
    elif short_conf > long_conf * 1.2:
        final_direction = "SHORT"
    else:
        final_direction = "HOLD"

    return {
        'asset': asset,
        'symbol': f"{asset}USDT",
        'final_recommendation': final_direction,
        'long_confidence': long_conf,
        'short_confidence': short_conf,
        'signals': recommendations,
        'current_price': data['btc_price'].iloc[-1]
    }


# Example usage
if __name__ == "__main__":
    result = analyze_signals("output/2025-12-24_123456")

    print(f"Asset: {result['asset']}")
    print(f"Symbol: {result['symbol']}")
    print(f"Recommendation: {result['final_recommendation']}")
    print(f"Current Price: ${result['current_price']:,.2f}")
    print("\nSignal Details:")
    for sig in result['signals']:
        print(f"  {sig['signal']}: {sig['trade_direction']} "
              f"(score={sig['score']:.3f}, contrarian={sig['is_contrarian']})")
```

## Signal Definitions Reference

| Signal | Description | Typical Range |
|--------|-------------|---------------|
| `borrow_repay_ratio` | Borrow / Repay volume ratio | 0.8 - 1.2 |
| `borrow_momentum` | 1-hour borrow change rate | -0.1 to 0.1 |
| `repay_momentum` | 1-hour repay change rate | -0.1 to 0.1 |
| `rsi_raw` | Raw RSI (3-min basis) | 0 - 100 |
| `rsi_zscore` | RSI normalized (z-score) | -3 to 3 |
| `total_borrow` | Raw borrow volume | Varies |
| `total_repay` | Raw repay volume | Varies |
| `funding_rate` | Perpetual funding rate | -0.001 to 0.001 |
| `funding_zscore` | Funding rate normalized | -3 to 3 |
| `open_interest` | Futures open interest | Varies |
| `oi_momentum` | 1-hour OI change rate | -0.05 to 0.05 |
| `oi_zscore` | OI normalized | -3 to 3 |
| `net_flow` | Borrow - Repay (net flow) | Varies |
| `net_flow_momentum` | 1-hour net flow change | -0.1 to 0.1 |
| `ratio_momentum` | 1-hour ratio change | -0.05 to 0.05 |

## Key Trading Rules

1. **Always check `is_contrarian`** - Many strong signals work in reverse
2. **Prefer signals with `granger_significant = True`** - Statistically validated
3. **Higher `composite_score` = more reliable** - Use > 0.4 as threshold
4. **Use multiple signals** - Aggregate top 3-5 for consensus
5. **Check `lead_lag_score`** - Higher means more predictive
6. **Monitor `current_score` in metrics** - Shows current signal strength
